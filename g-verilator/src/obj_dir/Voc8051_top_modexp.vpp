`begin_keywords "1800-2012"
`line 1 "modexp.v" 1
module modexp(clk, rst, start, ready, m, e, n, c);
  parameter [15:0] W = 2048;
  
  input clk, rst;

`line 6 "modexp.v" 0
  input  [W-1:0] m;
  input  [W-1:0] e;
  input  [W-1:0] n;  
  output [W-1:0] c;   

`line 11 "modexp.v" 0
  input start;
  output ready;

`line 14 "modexp.v" 0
  localparam IDLE  = 3'b000;
  localparam BUSY1 = 3'b001;
  localparam WAIT1 = 3'b010;
  localparam BUSY2 = 3'b011;
  localparam WAIT2 = 3'b100;

`line 20 "modexp.v" 0
  reg[2:0] state;

`line 22 "modexp.v" 0
  reg [15:0] i;
  wire [15:0] i_next;

`line 25 "modexp.v" 0
  reg [W-1:0] c;
  wire [W-1:0] c_next;
  wire [W-1:0] p;
  wire [W-1:0] sq;

`line 30 "modexp.v" 0
  wire sq_ready;
  wire sq_start;
  wire m_ready;
  wire m_start;

`line 35 "modexp.v" 0
  wire state_idle = state == IDLE;
  wire state_busy1 = state == BUSY1;
  wire state_wait1 = state == WAIT1;
  wire state_busy2 = state == BUSY2;
  wire state_wait2 = state == WAIT2;

`line 41 "modexp.v" 0
  wire ei = e[i[10:0]];

`line 43 "modexp.v" 0
  wire [2:0] state_next_idle = start ? BUSY1 : IDLE;

`line 45 "modexp.v" 0
  wire [2:0] state_next_busy1 = m == 0 ? IDLE
                              : (c == 1 && ei == 0) ? BUSY1
                              : WAIT1;

`line 49 "modexp.v" 0
  wire [2:0] state_next_wait1 = !sq_ready ? WAIT1
                              : ei ? BUSY2
                              : (i == 0) ? IDLE
                              : BUSY1;

`line 54 "modexp.v" 0
  wire [2:0] state_next_wait2 = !m_ready ? WAIT2
                              : (i == 0) ? IDLE
                              : BUSY1;

`line 58 "modexp.v" 0
  wire [2:0] state_next = state_idle? state_next_idle
                        : state_busy1 ? state_next_busy1
                        : state_wait1 ? state_next_wait1
                        : state_busy2 ? WAIT2
                        : state_next_wait2;

`line 64 "modexp.v" 0
  wire ready = (state == IDLE);

`line 66 "modexp.v" 0
  modmul #(.W(W)) square(
    .clk        (clk),
    .rst        (rst),
    .start      (sq_start),
    .ready      (sq_ready),
    .a          (c),
    .b          (c),
    .n          (n),
    .p          (sq)
  );

`line 77 "modexp.v" 0
  modmul #(.W(W)) mult(
    .clk        (clk),
    .rst        (rst),
    .start      (m_start),
    .ready      (m_ready),
    .a          (c),
    .b          (m),
    .n          (n),
    .p          (p)
  );

`line 88 "modexp.v" 0
  wire next_busy = state_next == BUSY1;

`line 90 "modexp.v" 0
  assign i_next = (state_idle && next_busy) ? W-2
                : (next_busy) ? i-1
                : i;

`line 94 "modexp.v" 0
  assign c_next = m == 0 ? 0
                : (state_idle && next_busy) ? (e[W-1] ? m : 1)
                : (sq_ready && state_wait1) ? sq
                : (m_ready && state_wait2) ? p
                : c;

`line 100 "modexp.v" 0
  assign sq_start = state == BUSY1;
  assign m_start = state == BUSY2;

`line 103 "modexp.v" 0
  always @(posedge clk)
  begin
    if (rst) begin
      i         <= W-1;
      state     <= IDLE;
      c         <= 1;
    end
    else begin
      i         <= i_next;
      state     <= state_next;
      c         <= c_next;
    end
  end
endmodule

`line 118 "modexp.v" 2
