`begin_keywords "1800-2012"
`line 1 "modmul.v" 1


`line 8 "modmul.v" 0

`line 8 "modmul.v" 0

`line 8 "modmul.v" 0

`line 8 "modmul.v" 0

`line 8 "modmul.v" 0

`line 8 "modmul.v" 0
 


`line 11 "modmul.v" 0
module modmul(clk, rst, start, ready, a, b, n, p);
  parameter W=2048;

`line 14 "modmul.v" 0
   
  input clk, rst;

`line 17 "modmul.v" 0
   
  input  [W-1:0] a;
  input  [W-1:0] b;
  input  [W-1:0] n;
  output [W-1:0] p;

`line 23 "modmul.v" 0
   
  input start;
  output ready;

`line 27 "modmul.v" 0
  parameter IDLE = 1'b0, BUSY = 1'b1;
  reg state;

`line 30 "modmul.v" 0
  reg [15:0] i;
  wire [15:0] i_next;

`line 33 "modmul.v" 0
  wire finished_p = (i == (W-1));
  wire state_next_idle = start ? BUSY : IDLE;
  wire state_next_busy = finished_p ? IDLE : BUSY;
  wire state_next = (state == IDLE) ? state_next_idle : state_next_busy;
  wire ready = (state == IDLE);

`line 39 "modmul.v" 0
  reg [W+3:0]  pi; 
  wire [W-1:0] p = pi[W-1:0];

`line 42 "modmul.v" 0
  wire [W+3:0] p2, abi, pi0, pi1, pi1p, pi2, pi2p;

`line 44 "modmul.v" 0
  wire [W+3:0] pi_next = (state == IDLE && state_next == BUSY)  ? 0
                       : (state == BUSY)                        ? pi2p
                       : pi;

`line 48 "modmul.v" 0
  assign p2 = pi << 1;
  assign abi = b[W-1-i] ? {4'b0, a} : 0;
  assign pi0 = p2 + abi;
  assign pi1 = pi0 - {4'b0, n};
  assign pi1p = pi1[W+3] == 0 ? pi1 : pi0;
  assign pi2 = pi1p - {4'b0, n};
  assign pi2p = pi2[W+3] == 0 ? pi2 : pi1p;

`line 56 "modmul.v" 0
  assign i_next = (state == BUSY)                        ? i + 1 
                : (state == IDLE && state_next == BUSY)  ? 0
                : i;

`line 60 "modmul.v" 0
  always @(posedge clk)
  begin
    if (rst) begin
        i           <= 0;
        state       <= IDLE;
        pi          <= 0;
    end
    else begin
        i           <= i_next;
        pi          <= pi_next;
        state       <= state_next;
    end
  end
endmodule

`line 75 "modmul.v" 2
